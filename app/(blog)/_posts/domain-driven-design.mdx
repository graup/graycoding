---
title: "Domain Driven Design as a bridge between design and engineering"
publishedAt: "2024-11-15"
summary: "Advice for junior software engineers from abroad who are interested in working in Korea."
tags: product
---

Product managers write Google docs.
Designers draw in Figma.
Engineers create diagrams and code.
Marketing creates campaigns in Hubspot.
Customer support writes in Zendesk.
How do we make sure that everyone is on the same page regarding our product?
That the design and implementation reflect the user's mental model?
That everyone from CEO to support uses the same language as the UI and our users?

Domain Driven Design (DDD) is a methodology pioneered by engineers to improve communication among stakeholders.
It also is a set of software architecture patterns, but that's not what I'm talking about here.
I see it first and foremost as a way to bridge the gap between design and engineering.

How does it work?

The key is Ubiquitous Language.

## Ubiquitous Language

In DDD, we define a language that is shared among all stakeholders.
This is the common language of the business, the language of the user – and also the language of the code.

A Ubiquitous Language is defined through _discovery_ by domain experts.

Domain experts are all stakeholders of your business in any way related to your product.
That can include management, support, engineers, designers, users.
It is crucial that not any one group defines the language on their own.

## Start with business strategy

> To design and build an effective solution, you have to understand the problem.
> To understand the problem, you have to understand the context within which it exists.

A good exercise you can start with is to define the business domain and subdomains.
Subdomains can be useful to organize your team and architecture around.

- **Business Domain**: main area of activity
  - FedEx: courier delivery; Starbucks: coffee shops; Walmart: retail
  - This may be obvious to you but different people on your team may have different ideas about what the business does.
- **Subdomain**: fine-grained area of business activity. what are all the parts that make up the business?
  - Core subdomains: differentiators, high cost of switching, competitive advantage, strategy, secret sauce.
  - Generic subdomains: important parts but possible to use battle-tested generic implementations instead of building your own.
  - Supporting subdomains: non-generic, but also no competitive advantage; e.g. simple CRUD parts. Ideally can be turned into generic subdomains.
  - The focus of business efforts should be on core subdomains.
  - Subdomains don’t always need to involve your own technical systems. It can also be a manual process or a third-party service.
  - How to differentiate
    - Would someone pay for it on its own? → Core subdomain
    - Would it be simpler and cheaper to hack your own implementation, rather than integrating an external one? → Supporting subdomain
      ![https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098100124/files/assets/lddd_0101.png](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098100124/files/assets/lddd_0101.png)
  - When to stop decomposing subdomains into smaller parts?
    - Identify sets of coherent use cases that operate on the same data

## Discovering Domain Knowledge

> A software project’s success depends on the effectiveness of knowledge sharing between domain experts and software engineers.
> Effective knowledge sharing between domain experts and software engineers requires effective communication.

Traditional software development lifecycle implies top-down _translations_ (domain knowledge → analysis model → requirements → system design → source code)

Instead of translations, we define a **Ubiquitous language** shared among all stakeholders.
This is the language of the business, the language of the user, and the language of the code.

Try to avoid technical jargon, ambiguous or synonymous terms, implicit assumptions, and extraneous details.

Use whatever tool you have to document the language.

## Managing Domain Complexity

> On an organizational scale, the domain experts’ mental models can be inconsistent themselves. Different domain experts can use different models of the same business domain.

- Inconsistencies among domain experts
  - Not good:
    - Making a model fit everything → ineffective
    - Making terms more complex → cognitive load, implementation misaligned with ubiquitous language
  - Good: **Bounded context** (model boundary)
- A ubiquitous language is _not_ universal.
- **Subdomains are discovered, bounded contexts are designed.**
- Bounded contexts and ubiquitous language enable modeling, defining implementation scopes and ownership (1 team per bounded context)

## Integrating Bounded Contexts

> Multiple bounded contexts may represent the same business entities but model them to solve a different problem. Although they can evolve independently, they have to integrate with one another. **Contracts** are touchpoints between bounded contexts, in particular regarding core subdomains.

- Integration models
  - Cooperation
    - Partnership
      - Bounded contexts are integrated in an ad hoc manner.
    - Shared Kernel
      - Multiple bounded contexts share a limited overlapping model that belongs to all participating bounded contexts.
      - Continuous integration: Changes to the shared kernel must trigger integration tests for all the affected bounded contexts.
  - Customer-Supplier
    - Conformist
    - Anticorruption layer
    - Open-Host Service
      - uses published language (decoupled from ubiquitous language)
- Non-integration
  - Useful for generic subdomains (re-implementing is cheap) or wildly different models (cooperation is expensive)

## Evolving Design Decisions

> As an organization grows and evolves, it’s not unusual for some of its subdomains to morph from one type to another.

- Strategic

  ![https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098100124/files/assets/lddd_1101.png](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098100124/files/assets/lddd_1101.png)

- Tactical
  - Refactorings/upgrades towards more complex patterns
- Organizational
  - When splitting up teams, need to re-define integration contracts.
- Domain Knowledge

> As time goes by, documentation often becomes stale, people who were working on the original design leave the company, and new functionality is added in an ad hoc manner until, at one point, the codebase gains the dubious status of a legacy system. **It’s vital to prevent such degradation of domain knowledge proactively.**

- Heuristics
  - When a subdomain’s functionality is expanded, try to identify more finer-grained subdomain boundaries that will enable you to make better design decisions.
  - Don’t allow a bounded context to become a “jack of all trades.” Make sure the models encompassed by bounded contexts are focused to solve specific problems.
  - Make sure your aggregates’ boundaries are as small as possible. Use the heuristic of strongly consistent data to detect possibilities to extract business logic into new aggregates.

## EventStorming

- Low-tech (pen and paper) group activity to discover and share domain knowledge
  - Scope: the business process that the group is interested in exploring
  - Explore the process as a series of domain events, represented by sticky notes, over a timeline
  - Enhance with additional concepts—actors, commands, external systems, etc.
- Steps
  1. Unstructured Exploration: brainstorming of domain events (past tense). Orange sticky notes
  2. Timelines: organize events in order, starting with “happy path”, then adding alternative scenarios
  3. Pain Points: identify bottlenecks, manual steps that require automation, missing documentation, or missing domain knowledge. Rotated pink sticky notes
  4. Pivotal Events: identify significant business events indicating a change in context or phase. Mark with vertical bar
  5. Commands: describe what triggered the event or flow of events. Blue sticky notes
  6. Policies: when commands are automatically executed when a specific domain event occurs. Purple sticky notes
  7. Read Models: the view of data within the domain that the actor uses to make a decision to execute a command. Green sticky notes.
  8. External Systems: Pink sticky notes.
  9. Aggregates
  10. Bounded Contexts

## More to consider in the real world

- Strategic Analysis
  - What is the organization’s business domain(s)?
  - Who are its customers?
  - What service, or value, does the organization provide to customers?
  - What companies or products is the organization competing with?
  - How is the company organized?
  - Define subdomains
  - Explore the Current Design
    - Evaluate strategy and tactics
- Modernization Strategy
  - Think big but start small
  - Reorganize the bounded context’s modules to reflect the business subdomains’ boundaries rather than technical implementation patterns
  - Strangler
    ![https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098100124/files/assets/lddd_1304.png](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098100124/files/assets/lddd_1304.png)
  - Refactoring
    - Small steps!

## Further Reading

- Khononov, Vlad. [Learning Domain-Driven Design](https://www.oreilly.com/library/view/learning-domain-driven-design/9781098100124/). O'Reilly, 2021.
- Stemmler, Khalil. [An Introduction to Domain-Driven Design (DDD)](https://khalilstemmler.com/articles/domain-driven-design-intro/). 2019
